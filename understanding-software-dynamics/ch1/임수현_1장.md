# [ 1장 ] 너무 느린 내 프로그램
#### 1.1 데이터 센터의 측면
- 예산의 기준이 되는 트랜잭션의 수를 정할 때 꼬리 지연시간의 제약을 초과할 때까지 부하 성능을 올린 후 성능을 조금씩 줄여가며 경험적으로 결정한다. 

#### 1.2 데이터 센터 하드웨어
- 각 서버는 여러 프로그램을 실행하고 각 프로그램은 여러 스레드로 동작한다.  
- 유후 상태의 프로세서가 있을 경우 사용자와 대면하지 않는 배치 프로그램을 일부 실행하면 경제적이다.
- 사용자와 대면하는 프로그램과 뒷단에서 동작하는 프로그램 외에도 모든 서버에서는 항상 몇 개의 시스템 관리용 프로그램을 실행해 서버의 사용량과 오류의 수, 디스크 공간의 여유분 등을 지속적으로 추적한다. 

#### 1.3 데이터 센터 소프트웨어
- 데이터 센터 소프트웨어는 동시에 병렬로 동작하는 여러 서비스가 계층을 이뤄 각자 개별적인 요청을 처리하고, 하나의 서비스가 여러 인스턴스로 동작해서 각자의 서비스가 각기 다른 지연시간 목표에 맞춰 빠르게 응답할 수 있도록 노력한다. 
- 성능이 향상될 수 있도록 많은 계층이 최근 데이터와 연산 결과를 보유하는 소프트웨어 캐시를 보유한다. 
- 다른 계층 간 RPC는 호출자가 기다리는 동기(synchronous) 방식이거나 호출자는 계속해서 실행하고 여러 서버에서 병렬로 RPC를 처리하는 비동기적인(asynchronous) 방식일 수 있다.
- RPC가 병렬로 끝나면, 일반적으로 가장 느리게 끝난 시간이 전체 응답 시간을 결정한다.

> 실행 왜곡(execution skew)이란?  
> 실행 왜곡은 분산 시스템에서 병렬로 수행되는 작업들 간에 발생하는 시간 차이를 의미합니다. 여러 작업이 동시에 시작되지만, 일부 작업이 예상보다 빠르거나 느리게 완료되는 상황을 말합니다. 이러한 불균형은 전체 응답 시간에 영향을 미쳐, 가장 느린 작업이 완료될 때까지 시스템의 성능을 저하시킬 수 있습니다. 실행 왜곡은 시스템의 부하가 균등하게 분배되지 않거나, 자원 경합이나 하드웨어의 성능 차이로 인해 발생할 수 있습니다.

#### 1.4 긴 꼬리 지연시간
![IMG_6111](https://github.com/user-attachments/assets/d00c0619-5f94-441c-9b74-a2bd9004828d)
> **정상적인 지연시간으로 1, 3, 20 msec이 측정된 이유**
> <br> 정상적인 지연 시간은 시스템이 최적의 상태에서 동작할 때의 응답 시간을 나타냅니다. 
> <br> - 1 msec: 매우 빠른 응답 시간은 네트워크 패킷의 전송이나 메모리 접근과 같은 아주 간단한 작업에 해당할 수 있습니다. 이는 CPU에서 캐시된 데이터를 처리하거나 매우 가까운 서버 간의 통신에서 발생할 수 있습니다.
> <br> - 3 msec: 약간 더 복잡한 연산이나 캐시 미스에 의한 메모리 접근을 포함할 수 있습니다. 네트워크 통신에서 약간의 거리 차이나 경로의 변화에 따라 발생할 수 있는 시간입니다.
> <br> - 20 msec: 비교적 큰 데이터 처리나 디스크 접근을 포함하는 작업의 지연 시간입니다. 데이터베이스 쿼리나 파일 시스템 접근이 관련될 수 있습니다. 이 지연 시간은 여전히 정상적이며, 많은 애플리케이션에서 허용 가능한 수준입니다.  
> 이러한 정상적인 지연 시간은 시스템이 부하가 적고 자원 경합이 없을 때의 성능을 반영합니다.

> **긴(비정상적인) 지연시간으로 250, 500, 750 msec이 측정된 이유** 
> <br> 긴 지연 시간은 여러 요인으로 인해 시스템의 응답이 느려진 상황을 나타냅니다. 
> <br> - 250 msec: 자원 경합으로 인해 CPU, 메모리, 디스크, 또는 네트워크 자원이 부족하여 지연이 발생할 수 있습니다. 캐시 미스나 스왑 메모리 사용과 같은 상황이 원인이 될 수 있습니다. 
> <br> - 500 msec: 네트워크 혼잡이나 대기 시간이 길어지면서 패킷 손실이 발생하거나 재전송이 필요할 경우입니다. 디스크 입출력(I/O) 대기 시간의 증가나 데이터베이스에서의 복잡한 쿼리가 실행될 때도 이러한 지연이 발생할 수 있습니다.
> <br> - 750 msec: 대규모의 데이터 처리 작업이 동시에 발생하거나 외부 시스템과의 통신이 실패하여 재시도가 필요한 경우입니다. 이는 시스템 자원의 심각한 경합, 장애, 또는 네트워크 장애와 같은 비정상적인 상황을 반영합니다.  
> 이러한 긴 지연 시간은 시스템의 병목 현상, 자원 부족, 네트워크 이슈 등으로 인해 사용자의 응답 시간에 불균형적으로 큰 영향을 미칩니다.

#### 1.5 프레임워크에 관한 고찰

- 가끔씩 느린 트랜잭션의 성능의 문제를 해결하려면 느린 코드의 계층을 파악하고 이를 방해하는 요소가 무엇인지 찾아낸 다음 수정하면 된다.
- 복잡한 소프트웨어의 성능을 시험하는 프레임워크 
  ![IMG_6112](https://github.com/user-attachments/assets/b9881788-c1dd-4976-b9eb-4939f06a5e88)


#### 1.6 크기 정도 산정
- 예상치 못한 시간을 더 쉽게 발견하려면 예상 시간에 대한 크기 정도를 산정해야 한다.
- 모든 프로그래머가 알아야 하는 응답지연 값  
(출처: 가상 면접 사례로 배우는 대규모 시스템 설계 기초)
<img width="364" alt="스크린샷 2024-08-05 오후 4 42 40" src="https://github.com/user-attachments/assets/4f04d889-206f-4633-af90-8fdce3657c96"> 

#### 1.7 트랜잭션이 느린 이유
- 여러 계층으로 나뉜 소프트웨어에서 한 계층의 일반적인 지연의 원인은 대부분 낮은 계층에서의 응답을 기다리면서 발생한다. 이를 찾을 수 있도록 각 계층이 얼마나 오래 걸리는지 관찰하고 측정된 값으로 병목 현상이 있는 위치를 신속하고 명확하게 찾는 방법을 설계해야 한다. 
- 한 서버에서의 간섭은 분명히 서버로 들어오고 나가는 네트워크 트래픽을 포함해서 서버의 어떤 것에서 발생한다. 이런 간섭은 거의 대부분 공유되는 자원에 대한 경합 때문에 발생하곤 한다.
  
> 표준 성능 측정 도구(standard performance tools)란?
> <br>표준 성능 측정 도구는 시스템의 성능을 평가하고 모니터링하기 위해 사용되는 도구들로, 다양한 성능 지표를 측정하여 병목 현상 및 최적화 지점을 파악하는 데 도움을 줍니다. 이 도구들은 시스템 관리자 및 개발자가 시스템의 효율성을 유지하고 개선하는 데 유용합니다.
> <br> 일반적인 성능 측정 도구 예시
> <br> - CPU 사용률 모니터링: top (Unix/Linux), Task Manager (Windows), htop (Unix/Linux)
메모리 사용량 추적: vmstat (Unix/Linux), free (Unix/Linux)
> <br> - 디스크 I/O 분석: iostat (Unix/Linux), perfmon (Windows)
> <br> - 네트워크 트래픽 분석: iftop (Unix/Linux), Wireshark (Cross-platform)
> <br> - 애플리케이션 성능 추적: JProfiler (Java Applications), New Relic (Web Applications), AppDynamics (Distributed Applications)



#### 1.8 5가지 기본적인 자원들
- 간섭은 5가지 기본적인 자원의 공유로 인해 발생한다.
  - 한 서버에서 실행되지만 서로 관련 없는 프로그램 사이에 공유되는 컴퓨터 하드웨어 자원은 오직 4가지만 존재한다: **CPU, 메모리, 디스크 / SSD, 네트워크**
  - 한 프로그램에 복수 개의 스레드가 있다면 5번째 기본적인 자원이 추가된다: **소프트웨어 임계 구역**

> 임계 구역(critical section)이란?  
> 임계 구역은 여러 스레드가 동시에 실행될 때, 공유 자원에 접근하는 코드의 부분을 말합니다. 임계 구역에서는 데이터의 일관성을 보장하기 위해, 한 번에 하나의 스레드만 접근할 수 있도록 동기화 메커니즘이 필요합니다.

> 동기화 기법 예시
> <br> - 뮤텍스(Mutex): 뮤텍스는 스레드가 임계 구역에 진입하기 전, 잠금(Lock)을 획득하고, 나올 때 잠금을 해제하는 방식으로 동작합니다. 다른 스레드는 잠금이 해제될 때까지 대기합니다. 이는 가장 기본적인 동기화 방식으로, 임계 구역에 한 번에 하나의 스레드만 접근할 수 있도록 합니다.
> <br> - 세마포어(Semaphore): 세마포어는 정해진 개수만큼의 스레드가 임계 구역에 들어갈 수 있도록 제어합니다. 이는 카운팅 메커니즘을 통해 작동하며, 여러 스레드의 동시 접근을 허용할 수 있습니다. 이진 세마포어는 뮤텍스와 유사하게 동작하여 하나의 스레드만 허용하고, 카운팅 세마포어는 지정된 수만큼의 스레드를 허용합니다.
> <br> - 조건 변수(Condition Variable): 조건 변수는 특정 조건이 만족될 때까지 스레드를 대기 상태로 만들고, 조건이 충족되면 스레드를 깨워서 작업을 계속하도록 합니다. 일반적으로 모니터와 함께 사용되며, 동기화된 메소드 내에서 상태의 변화를 감시하고 제어하는 데 유용합니다.
> <br> - 스핀락(Spinlock): 스핀락은 잠금을 얻기 위해 대기하는 동안 스레드가 활성 상태로 루프를 돌며(lock이 풀릴 때까지) 대기하는 방식입니다. CPU를 점유한 상태로 대기하므로, 잠금이 짧은 시간 동안만 필요한 경우에 적합합니다. 긴 잠금 시간 동안은 비효율적일 수 있습니다.
> <br> - 바리어(Barrier): 바리어는 여러 스레드가 지정된 지점에 도달할 때까지 대기시키며, 모든 스레드가 도달하면 다음 단계로 넘어갈 수 있게 해주는 동기화 방법입니다. 주로 병렬 작업의 동기화를 위해 사용됩니다


#### 1.9 요약
- 매번 느린 코드보다는 가끔씩 느려지는 코드에 관심을 가지는 것이 좋다.
- 긴 꼬리 지연시간은 사용자의 전체 응답 시간에 불균형하게 영향을 미치며 서버의 작업 성능도 불균형하게 감소시킨다. 
- 느린 트랜잭션은 어떤 형태로든 간섭을 받는데, 계층이 많은 데이터 센터 소프트웨어에서는 어느 계층이 실제로 느린지 파악하기 어려워서 결국 어떤 간섭이 느린지 찾아내는 것은 쉽지 않다. 
- 정확한 위치를 찾으려면 계층화된 소프트웨어와 서로 간섭할 가능성이 있지만 관련되지 않는 프로그램을 실행하는 서버를 관찰하는 적절한 관찰 도구를 설계해야 한다. 