# [ 2장 ] CPU 측정

#### 2.0 서론
- CPU 시간: 컴퓨터 명령이 얼마나 오래 걸리는가
- 명령어의 지연시간은 일반적으로 첫 번째 "실행"부터 그 결과를 사용하는 후속 명령어의 첫 번째 "실행"까지 CPU 사이클을 의미한다.

#### 2.1 과거에서 지금까지의 발자취
- 속도를 높일 수 있도록 IBM 7094 II 같은 후속 장비에서는 첫 번째 명령어를 실행하는 동안 두 번째 명령어는 임시로 **명령어 레지스터**에 보관했다.
- **트랜지스터**의 출현으로 CPU 사이클 시간은 더 빨라졌지만, 코어 메모리 접근 시간은 더 나아지지 않았다.
- IBM 7030은 **명령어 파이프라이닝, 복수의 명령어 실행 유닛, 조건 분기를 넘어선 예측 실행, 3개 이상 복수개의 데이터 레지스터와 복수개의 메모리 뱅크**를 탑재한 최초의 장비였으며 속도 향상 기술을 적용한 역작이었다.
- 모든 메모리 접근마다 가상 주소를 물리 주소로 맵핑하는 **변환 색인 버퍼**(TLB, Translation Lookaside Buffer)를 사용하면 초기 CPU 사이클 타임은 다소 느려도, 대용량 데이터가 있는 대형 프로그램이 수동적인 명령어와 메인 메모리와 백업 디스크나 드럼 간 데이터를 주고받는 오버레이 입출력(I/O) 기술을 더 빠르게 사용할 수 있었다. 또한 **보호 비트**(protection bit)는 개별 페이지에 쓰기 금지나 실행 금지 등을 설정해 프로그램 보안을 향상할 수 있게 한다.
- 첫 번째 CPU 사이클에서 A와 B 두 명령어를 병렬로 가져와 실행하는 것을 **슈퍼스칼라 설계**라고 부른다.
- 일반적으로 CPU 코어 하나당 한 쌍의 작지만 속도가 빠른 1단계의 L1 캐시가 있다. 이 중 하나는 명령어를 캐싱하는 **L1-I캐시**이고 다른 하나는 데이터를 캐싱하는 **L1-D캐시**이다. 또 하나 이상의 코어끼리 공유되는 중간 크기, 중간 속도로 명령어 캐시와 데이터 캐시가 결함된 2단계 **L2 캐시**가 있고, 크고 느린 **L3 캐시**, 마지막 단계 캐시인 **LLC**(last-level cache)는 모든 코어 간 공유된다. [(추가 자료)](https://12bme.tistory.com/402)
- 21세기 초, **동시 멀티스레딩**(SMT, Simultaneous multithreading)이 도입됐다. [(추가 자료)](https://www.ibm.com/docs/ko/i/7.3?topic=performance-determining-when-use-simultaneous-multithreading)



#### 2.2 지금의 위치
- 빠른 마이크로프로세서 CPU 코어
  ![IMG_6110](https://github.com/user-attachments/assets/cbf8dedc-7bda-44f0-9141-6489aba24996)


#### 2.3 add 명령어의 지연시간 측정
- 보통 명령어의 지연시간에는 명령어 패치와 명령어 해석 시간, 명령어 수행 결과 쓰기 시간(결과가 사이클 손실 없이 전달되는 경우)은 포함하지 않는다. 하지만 분기 명령어의 지연시간은 명령어 패치부터 다음 명령어의 패치까지의 CPU 사이클을 의미하므로 명령어 패치와 해석, 글고 조건부 분기의 단계에 여러 사이클이 소요되는 경우, 이 모든 것은 분기 지연시간으로 나타날 수 있다. 
- 사이클 카운터를 읽고 일부 작업을 수행한 후, 사이클 카운터를 닫시 읽고 나서 이 차이를 빼는 것이 부분적인 코드의 경과 시간을 측정하는 일반적인 방법이 됐다.
- 사이클을 실제 시간으로 바꾸려면 사이클 수와 [(피코, pico)](https://bubidi.tistory.com/126)초를 곱해야 한다. 



#### 2.5 간단한 반복문, 반복문 오버헤드 실수, 컴파일러 최적화 실수
- 이 경우 단일 add 명령어를 사용할 때보다 반복 횟수 n을 계산하는 반복문 내부의 증가, 비교, 조건 분기같은 명령어를 다수 포함한다. 
- gcc 옵티마이저(optimizer)는 효율적으로 처리하도록 1의 10억 제곱을 컴파일 타임에 미리 계산된 10억을 상수로 저장한다.


#### 2.6 사용되지 않는 변수로 인한 실패
- 표준 컴파일러 최적화는 프로그램의 다른 곳에서 사용되지 않는 계산식을 포함한 코드를 제거한다.


#### 2.8 의존적인 변수들
- 다중 실행이 가능한 장비에서 측정된 평균 0.5 사이클은 add가 반 사이클이 걸린다는 의미가 아니다. 어떤 add 명령어는 한 사이클이 걸리고, 다른 명령어는 동시에 중첩돼 실행됐기에 사실상 0 사이클로 측정되는 것일 뿐이다. 


#### 2.9 실제 실행 지연시간
- 실행시간 대신 실행 지연시간을 측정하려면 이전의 명령어의 결과에 의존하는지부터 확인해야 한다.
- 적극적으로 최적화를 수행하는 컴파일러는 정수의 더하기와 곱하기 같은 연산자에 대해 재정렬 연산(reorder computations)을 하기도 한다.


#### 2.10 몇 가지 추가 차이점
- 몇몇의 반복문은 결과가 부동소수점의 오버플로우(overflow)나 언더플로우(underflow)로 나타나 후속의 명령어가 이를 이용하는 데 직접적인 하드웨어 대신 10배 더 느린 방식으로 처리될 수도 있다. 


#### 2.11 요약
- 소프트웨어 성능 문제의 일부는 잘못 측정돼 관찰된 문제다. 일부는 실제 존재했지만 잘못 측정돼서 발견되지도 않는다.


