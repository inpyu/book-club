# CPU 측정

명령어의 지연 시간은 명령어를 실행하는 CPU 클럭 사이클에서부터 이 결과를 사용하는 후속 명령어 사이클까지의 시간이 된다.

하드웨어가 기본 함수를 얼마나 빨리 처리할 수 있는지, 컴퓨터는 하드웨어 이벤트가 발생하는 시점을 결정하는 클럭을 이용해서 만듦 -> 클럭의 시간 간격이 클럭 사이클

> 클럭 신호: CPU는 클럭 신호(Clock Signal)에 따라 동작 클럭 신호는 일정한 주기로 반복되는 전기 신호로, CPU의 모든 동작을 동기화 

> 사이클: 클럭 신호가 한 번의 주기를 완료하는 시간

### 과거에서 지금까지의 발자취

CPU 클럭 사이클과 코어 메모리 사이클 시간이 동일해서 간단한 명령 완료하는데 두 사이클 걸림 

(명령어 패치, 메모리로부터 명령어 해석 + 데이터에 접근해 명령어 실행)

트랜지스터 사용으로 CPU 사이클 시간 더 빨라짐 

1) 스위칭 속도: 트랜지스터는 진공관에 비해 훨씬 더 빠르게 스위칭할 수 있습니다. 이것은 전기 신호가 더 빠르게 이동할 수 있음을 의미하며, CPU의 사이클 시간이 단축되었습니다.

2) 크기와 효율성: 트랜지스터는 진공관보다 훨씬 작고 효율적입니다. 이는 더 많은 트랜지스터를 더 작은 공간에 집적할 수 있음을 의미합니다. 결과적으로 CPU는 더 많은 연산을 더 짧은 시간 안에 처리할 수 있습니다.

3) 전력 소모: 트랜지스터는 진공관보다 훨씬 적은 전력을 소비합니다. 이는 발열을 줄이고, 더 높은 속도로 동작할 수 있게 합니다.

하지만,RAM과 같은 메모리 기술의 발전은 CPU만큼 빠르지 않았다. 메모리의 구조적 제한과 전력 소모 문제 등으로 인한 것


### 지금의 위치

속도 향상 기술 사용
> 뭐였는지 잘 기억이 안남 ㅠ

### add 명령어의 지연 시간 측정

명령어의 지연시간은 일반적으로 첫번째 실행부터 그 결과 사용하는 후속 명령어의 첫번쨰 실행까지 CPU 사이클 의미

하지만 한 번의 사이클을 실행하면 왜곡 발생 가능하여 수천 개 묶어서 실행하는 게 좋다.

```
시간 읽기
  add 명령어 N번 실행
시간 읽기
두시간 차이 뺴고 N으로 나누기
```
add당 평균 시간을 구할 수 있지만, 하나의 add 명령어에 대한 지연시간과는 차이가 있을 수 있다. 왜?

### 직선형 코드의 실수

명령어 캐시나 메모리에서 1000개 이상의 순차적 명령어를 패치하는 비율이나 1단계 데이터 캐시에서 합계 데이터를 불러오거나 저장하는 데 걸리는 시간 ..?

### 간단한 반복문, 반복문 오버헤드 실수, 컴파일러 최적화 실수

### 사용되지 않는 변수로 인한 실패

처음 측정하려고 한 것과 다른 것이 측정되는 일이 빈번

> 상위 수준 컴파일 언어로 작성되면 이렇게 오류 발생,,, 그럼 어떻게 하는데요,, 

> GCC는 GNU 컴파일러 모음(GNU Compiler Collection)

컴파일 단계 
- 전처리 단계 : 전처리기(Preprocessor)를 통해 소스 코드 파일(*.c)과 헤더 파일(*.h)을 합쳐 전처리된 소스코드 파일(*.i)로 변환한다. 
- 컴파일 단계 : 컴파일러(Compiler)를 통해 전처리된 소스코드 파일(*.i)을 어셈블리어 파일(*.s)로 변환한다.
- 어셈블리 단계 : 어셈블러(Assembler)를 통해 어셈블리어 파일(*.s)을 오브젝트 파일(*.o)로 변환한다.
- 링킹 단계 : 링커(Linker)를 통해 오브젝트 파일(*.o)들과 라이브러리 파일들을 링크하여(묶어) 하나의 실행 파일로 변환한다.


### 향상된 반복문

### 의존적 변수들

### 실제 실행 지연시간

### 몇 가지 추가 차이점

.. 읽어봤지만,,,